/** -*- mode: c++ -*-
 *
 * jrl_algorithm
 *
 * Header-only definitions of algorithms and algorithm helpers.
 *
 * Copyright (C) 2015 Brian Davis
 * All Rights Reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: Brian Davis <bd@jollyrogerlabs.com>
 *
 */

#if !defined(JRL_ALGORITHM_GUARD)
#define JRL_ALGORITHM_GUARD

#include "jrl_util"
#include "stl_usability/algorithm_usability"

namespace jrl
{

namespace util
{

namespace algorithm
{

namespace jutil = jrl::util;

namespace detail
{

/**
 * Default extender
 */
template<typename _Container>
void
null_extender(_Container &__container, const size_t sz)
{
}

} // namespace detail

/**
 * @brief Insert a value at the end of a container only if it does not yet
 * exist in the container.
 * @param __container - container to insert the value into.
 * @param __val - value to insert into the container.
 * @param __extender - function-like type, taking the container size
 *                     as argument, to apply to __container when a new
 *                     element is successfully added.
 * @return a 2-tuple where the first element is true if the value was
 *         correctly inserted at the end of the container, false
 *         otherwsie, and the second element is the position at which
 *         the element was either inserted or found.
 *
 * @todo use type_traits to constrain the legal types for _Container
 * and _Extender template formal parameters.
 *
 */
template<typename _Container, typename _Extender =
	 std::function<void(_Container &, const size_t)>>
jutil::bool_return<typename _Container::size_type>
nondestructive_insert(_Container &__container,
		      const typename _Container::value_type &__val,
		      _Extender __extender = detail::null_extender<_Container>)
{
  using result_type = jrl::util::bool_return<typename _Container::size_type>;
  // @todo fix the following statement
  // static_assert(std::is_member_function_pointer<typename _Container::push_back>::value,
  // 		"_Container type parameter must be a class supporting a "
  // 		"push_back member function");
  typename _Container::const_iterator entry =
    std::find(__container.begin(), __container.end(), __val);
  if (__container.end() == entry) {
    __container.push_back(__val);
    __extender(__container, __container.size());
    // successful insert and extension
    return result_type(__container.size() - 1, true);
  }
  // value already exists
  return result_type(std::distance(entry, __container.cbegin()), false);
}

/**
 * Move all elements (potentially destructively) from source
 * container/range to target.
 */
template<typename _Container, typename _OutputIterator>
inline _OutputIterator
move_all(_Container &__src, _OutputIterator __tgt)
{
  for (auto &entry : __src) {
    *__tgt = std::move(entry);
    ++__tgt;
  }
  return __tgt;
}

/**
 * As per binary operator version of transform, but with a ternary
 * operator.
 *
 * @todo can this be done for n-ary operator using a variadic
 * template?
 */
template<typename _Container1, typename _Container2, typename _Container3,
	 typename _OutputIterator, typename _TernaryOperator>
inline _OutputIterator
transform(const _Container1 &__container1, const _Container2 &__container2,
	  const _Container3 &__container3, _OutputIterator __result,
	  _TernaryOperator __ternary_op)
{
  using C1Iter = _Container1::iterator;
  using C2Iter = _Container2::iterator;
  using C3Iter = _Container3::iterator;
  C1Iter c1 = __container1.begin();
  C2Iter c2 = __container2.begin();
  C3Iter c3 = __container3.begin();
  for (; __container1.end() != c1; ++c1, ++c2, ++c3, ++__result) {
    *__result = __ternary_op(*c1, *c2, *c3);
  }
  return __result;
}

} // namespace algorithm

} // namespace util

} // namespace jrl

#endif // JRL_ALGORITHM_GUARD
