-*- Mode: Outline -*-

* hash_map/hash_set
NOTE: hash_map should be derived from hash_set with value_type =
pair<key, value>
** create a separate hash_table_base class that will be used as the basis of all final classes
** key extraction
** policies
*** common policies between open addressing and bucket table
**** hash function
***** std::hash (default)
***** trivial
***** custom
needs research to determine if it makes sense to handle the case of a
free function differently
**** table length/hash value remap
***** prime length + modulus remap (default)
***** power of two length + mask remap
***** custom?
NOTE: it is vital that remap covers the space of table entries; this
property is guaranteed for modulus in all length styles, but not for
mask
**** rehash
***** static time configurable load factor threshold (default)
***** no rehash
***** custom?
**** allocator
***** std::allocator (default)
***** non-static
needs research
***** custom
**** critical section safety
***** none (default)
***** copy-on-write/read-copy-update
use the atomic pointer swap trick; always suitable for rehash, but not
suitable for add/update/delete
***** table reader/writer lock
covers all cases and probably most suitable for open addressing table
*** bucket table policies
**** bucket_container
choice of container policy may interact with choice of critical
section safety
***** vector (default)
***** list
***** cursor list
***** intrusive list
***** custom
**** critical section safety
***** none (default)
***** bucket reader/writer lock
only appropriate for bucket table, requires table lock or COW/RCU for
rehash
***** lock-free list?
needs research
*** open addressing table policies
**** probing
***** linear (default)
***** quadratic
***** double hash
***** custom
** basics
*** iterators
**** non-const
**** const
**** begin()
***** non-const
***** const
**** end()
***** non-const
***** const
**** cbegin()
**** cend()
*** standard interface
**** empty()
**** max_size() ??
**** emplace()
**** emplace_hint() ??
**** insert()
NOTE: argument is value_type
***** non-const ref
seems to be universal ref in standard impl
***** const ref
***** with hint
***** range
***** initializer list
**** erase()
***** non-const position iterator
***** const position iterator
***** key
***** range
**** clear()
**** swap()
**** hash_function()
returns the hash function object
**** key_eq()
returns the key comparison object
**** find()
***** non-const ref
***** const ref
**** count()
makes the most sense for multi-table, 0 or 1 for normal
**** equal_range()
makes the most sense for multi-table, 0 or 1 entries in the result for
normal
***** non-const key ref
***** const key ref
**** operator[]
***** non-const key ref
***** const key ref
**** at()
***** non-const key ref
***** const key ref
**** bucket_count()
**** max_bucket_count()
**** bucket_size()
number of entries in bucket (with index argument)
**** bucket()
bucket index of element (with key argument)
**** load_factor()
**** max_load_factor()
***** no-argument version returns
***** float argument version sets
**** rehash()
size_t argument, set the number of buckets to argument or greater and
rehash
**** reserve()
size_t argument, prepare the map to accept the number of elements
given by the argument
**** public type aliases
*** questionable interface functions
**** local_iterator + const_local_iterator versions of begin(), cbegin(), end(), cend()
*** constructors
**** copy
***** with allocator ??
**** move
***** with allocator ??
**** copy range
**** initializer list
*** assignment operator
**** copy
**** move
** testing
*** performance testing
** multi-threading policy
*** not-thread-safe
*** global reader/writer lock
*** per-bucket reader/writer lock
** ordered iterator traversal for trivial hash
*** requires special iterator + sorting of buckets
** other policies ??
*** cache hash value with element to reduce cost of equality test
* iterable_buffer_set
** Use of std::string...
presents issues of object lifetime and ownership which require extra
research regarding risk.  Possibly better to make a copy or eliminate
these altogether.
** object ownership
needs careful review, especially the case where the type is used to
store raw data from a socket.
** crazy idea: template the constructor
have specialization for const ref that will enforce non-modification
** libaio + scatter/gather
think about how to integrate with libaio and scatter/gather I/O.  A
template is probably in order.
** use uint8_t instead of char?
** support array view
** performance testing
* jrl_algorithm
** DONE - Convert to C++14
** Apply patches to nondestructive_insert
See @todo comments in the function definition.
* jrl_macro
** Get rid of magic number constants
Move to enum in internal namespace, seems like #define followed by
#undef will not work...
** add branch prediction hints
** add stack trace generation
should also demangle function names
configurable?
** add NDEBUG wrapper?
* jrl_util
** DONE - Convert to C++14
** Move utilities that require bitset to a separate file
** Eliminate TimeSpecWrap
Need to convert libbatch to some benchmarking library.
** DONE - Move all macro definitions to jrl_macro
** DONE Use enable_if + type_traits to constrain the template arguments for asBinary
* jrl_variadic
** testing
*** find a way to add tests for cases that should not compile
**** extraneous policies
**** conflicting policies for the same behavior
* log2int
** Convert to C++14
** Change name to jrl_log_base2
Possibly log_base2_int
** Use STL style names
** Log2IntStatic: allow types other than unsigned for Argument
* logging
** Convert to C++14
** allow switching of log stream
** Possibly incorporate ideas from log_wrap
Allow users to choose some other implementation such as Boost logging?
** Add admin control support
This opens a big can of worms, requiring the addition of an admin
server.  Should obviously be controlled by conditional compilation.
Investigate extant solutions to this problem.
** Use static buffers to allow logging in low memory conditions
* unitsafe
** Change name to jrl_unitsafe?
** Use type_traits to restrict use to base types
Only numeric types?
** Fix handling of type tags
*** mostly works now, but need to figure out how to handle operator<< correctly
See USE_EXPERIMENTAL_UNITSAFE_STREAM_OPERATOR

Works in test code but not pcbfixturing.
* additions
* project level modifications
** DONE - Move all test code to a separate directory
** Convert to C++14
log2int
logging
jrl_algorithm
jrl_macro
jrl_metaprogram
jrl_util
unitsafe
** convert to STL style names
log2int
logging
jrl_algorithm
jrl_macro
jrl_metaprogram
jrl_util
unitsafe
** Set up doxygen support
Review results and add/update documentary comments where necessary.
** Add conditional include of required headers
There should be a single INCLUDE_REQUIRED_HEADERS macro that controls
this behavior.
** Add gnu standard files
e.g. NEWS, LICENSE, etc
* review
** Standardize handling of namespaces
Add to coding standards.
** Verify that all files have appropriate licenses
* misc
** Create a coding style guideline for commenting macros
** Create a coding style guideline for internal/implementation namespaces
e.g. "impl" or "detail", used to indicate that certain definitions
should not be used externally.
