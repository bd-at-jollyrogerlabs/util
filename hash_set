/** -*- mode: c++ -*-
 *
 * hash_set
 *
 * Highly configurable hash set implementation with an interface that
 *  is compatible with std::unordered_set.
 *
 * Copyright (C) 2015 Brian Davis
 * All Rights Reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: Brian Davis <bd@jollyrogerlabs.com>
 *
 */

#if !defined(JRL_UTIL_HASH_SET_GUARD)
#define JRL_UTIL_HASH_SET_GUARD 1

#include <cassert>

#include <algorithm>
#include <experimental/optional>
#include <functional>
#include <limits>
#include <list>
#include <vector>

#include <boost/iterator.hpp>
#include <boost/iterator/iterator_facade.hpp>

#include "jrl_util"
#include "jrl_macro"
#include "jrl_metaprogram"

namespace
{
  enum {
    UNSUCCESSFUL_ADD = false,
    SUCCESSFUL_ADD = true,
    DO_NOT_INCREMENT = false,
    DO_INCREMENT = true,
    DO_NOT_OVERWRITE = false,
    DO_OVERWRITE = true
  };
} // unnamed namespace

namespace jrl
{

// @todo document the required interface for every policy that can be
// customized

// ********** policy tags **********

struct key_extractor_tag {};

struct predicate_tag {};

struct allocator_tag {};

struct hash_function_tag {};

struct table_length_tag {};

struct rehash_tag {};

struct bucket_container_tag {};

// ********** policy implementation classes **********

namespace detail
{
struct CanGetKeyFromConstructor
{
  static const bool value = true;
};
struct CannotGetKeyFromConstructor
{
  static const bool value = false;
};

} // namespace detail

// ***** key extractor policies *****

/**
 * default policy: key type is the same as value type
 * (e.g. hash_set<std::string>)
 */
struct default_key_extractor_policy
{
  template<typename ValueType>
  struct rebind
  {
    using key_type = ValueType;

    static const key_type &
    get_key(const ValueType &arg) noexcept
    {
      return arg;
    }

    using type = detail::CanGetKeyFromConstructor;

    static const bool can_get_key_from_constructor = type::value;

    static const key_type &
    key_from_ctor_args(key_type &&arg) noexcept
    {
      return arg;
    }
  };
};

/**
 * policy: extract the key from the first element of a std::pair
 *
 * NOTE: this is the correct policy for hash_map
 */
struct pair_first_element_key_extractor_policy
  : public key_extractor_tag
{
  template<typename ValueType>
  struct rebind
  {
    using key_type = ValueType;

    template<typename MappedType>
    static const key_type &
    get_key(const std::pair<key_type, MappedType> &arg) noexcept
    {
      return arg.first;
    }

    using type = detail::CanGetKeyFromConstructor;

    static const bool can_get_key_from_constructor = type::value;

    template<typename MappedType>
    static const key_type &
    key_from_ctor_args(const key_type&& key, const MappedType&& val) noexcept
    {
      return key;
    }
  };
};

// ***** predicate policies *****

/**
 * default policy: use std::equal_to
 */
struct default_predicate_policy
{
  template<typename KeyType>
  struct rebind : public std::equal_to<KeyType>
  {
  };
};

// ***** allocator policies *****

/**
 * default policy: allocate containers using std::allocator
 */
struct default_allocator_policy
{
  template<typename ValueType, template<typename...> class ContainerType>
  struct rebind
  {
    using type = ContainerType<ValueType, std::allocator<ValueType>>;
  };
};

// @todo think about how to handle stateful allocators

// @todo add pool/arena allocator policy

// @todo add custom allocator policy

// ***** hash function policies *****

/**
 * policy: calculate the hash value using std::hash
 */
// @todo need a good error message in the case where std::hash does
// not instantiate for the key type, current message is 'invalid use
// of incomplete type', which isn't very helpful
struct default_hash_policy
{
  template<typename KeyType, typename SizeType>
  struct rebind
  {
    SizeType
    operator()(const KeyType &key) const noexcept
    {
      return std::hash<KeyType>()(key);
    }
  };
};

/**
 * policy: no hash calculation, the key value is passed through
 * unchanged.
 */
struct trivial_hash_policy : public hash_function_tag
{
  template<typename KeyType, typename SizeType>
  struct rebind
  {
    SizeType
    operator()(const KeyType &key) const noexcept
    {
      return static_cast<size_t>(key);
    }
  };
};

/**
 * policy: allow a free function (subprogram) for calculating hash
 * values.
 */
template<typename Derived>
struct free_function_hash_policy : public hash_function_tag
{
  template<typename KeyType, typename SizeType>
  struct rebind
  {
    SizeType
    operator()(const KeyType &key) const noexcept
    {
      return Derived::hash(key);
    }
  };
};

#define MAKE_FREE_FUNCTION_HASH_POLICY(PolicyType, SizeType, hashFunc, KeyType) \
struct PolicyType : public jrl::free_function_hash_policy<PolicyType> \
{								      \
  static inline SizeType					      \
  hash(const KeyType &key) noexcept				      \
  {								      \
    return hashFunc(key);					      \
  }								      \
}

// ***** table length style policies *****

/**
 * default policy: table length is a prime number and hash values are
 * mapped to buckets using modulus (AKA operator%)
 */
struct default_table_length_policy
{
  template<typename SizeType>
  struct rebind
  {
    rebind()
    {
    }

    static SizeType
    initial_bucket_count() noexcept
    {
      return primes().at(INITIAL_BUCKET_COUNT_IDX);
    }

    /**
     * return the next legal bucket count that is greater than the
     * argument bucket count.
     */
    static SizeType
    next_bucket_count(const SizeType bucket_count)
    {
      size_t idx = 0;
      SizeType result = primes().at(idx);
      while (result <= bucket_count) {
	++idx;
	result = primes().at(idx);
      }
      return result;
    }

    static SizeType
    hash_to_bucket(const SizeType hash,
		   const SizeType bucket_count) noexcept
    {
      assert(is_in_primes(bucket_count));
      return hash % bucket_count;
    }

  private:
    using SizeTypeVec = std::vector<SizeType>;

    static const SizeTypeVec &
    primes()
    {
      static const std::vector<SizeType> PRIMES{
	17, 29, 37, 53, 67, 79, 97, 131, 193, 257, 389, 521, 769,
	1031, 1543, 2053, 3079, 6151, 12289, 24593, 49157, 98317,
	196613, 393241, 786433, 1572869, 3145739, 6291469,
	12582917, 25165843, 50331653, 100663319, 201326611,
	402653189, 805306457, 1610612741, 3221225473, 4294967291
      };
      return PRIMES;
    }

    static bool
    is_in_primes(const SizeType bucket_count)
    {
      return (std::end(primes()) !=
	      std::find(std::begin(primes()),
			std::end(primes()),
			bucket_count));
    }

  static const SizeType INITIAL_BUCKET_COUNT_IDX = 7;
  };
};

/**
 * policy: table length is a power of two and hash values are mapped
 * to buckets by masking away higher order bits
 */
struct power_of_two_length_table_policy : table_length_tag
{
  template<typename SizeType>
  struct rebind
  {
    rebind()
    {
    }

    static SizeType
    initial_bucket_count()
    {
      return INITIAL_BUCKET_COUNT;
    }

    /**
     * return the next legal bucket count that is greater than the
     * argument bucket count.
     */
    static SizeType
    next_bucket_count(const SizeType bucket_count)
    {
      SizeType result = 1;
      while (result <= bucket_count) {
	result <<= 1;
      }
      return result;
    }

    static SizeType
    hash_to_bucket(const SizeType hash,
		   const SizeType bucket_count) noexcept
    {
      assert(is_power_of_2(bucket_count));
      return hash & (bucket_count - 1);
    }

  private:
    static const SizeType INITIAL_BUCKET_COUNT = 128;
  };
};

// ***** rehash policies *****

template<typename SizeType>
using RehashCheckResult = std::experimental::optional<SizeType>;

/**
 * default policy: calculate the load factor and compare it to a
 * threshold in order to determine if the table should be rehashed
 */
template<typename SizeType, typename TableStyle, typename Derived>
struct load_factor_rehash
{
  using CheckResult = RehashCheckResult<SizeType>;

  static float
  max_load_factor()
  {
    return Derived::get_threshold();
  }

  /**
   * return nullopt_t if the table does not need to be rehashed, or
   * return the new bucket count if it does
   */
  static CheckResult
  rehash_check(SizeType current_bucket_count,
	       SizeType next_entry_count)
  {
    float load_factor = static_cast<float>(next_entry_count) /
      static_cast<float>(current_bucket_count);
    SizeType next_bucket_count;
    if (load_factor <= Derived::get_threshold()) {
      return std::experimental::nullopt;
    }
    while (load_factor > Derived::get_threshold()) {
      next_bucket_count =
	TableStyle::next_bucket_count(current_bucket_count);
      load_factor = static_cast<float>(next_entry_count) /
	static_cast<float>(next_bucket_count);
    }
    return next_bucket_count;
  }
};

/**
 * default policy for load_factor_rehash: rehash when the load factor
 * exceeds 1.5
 */
struct default_rehash_policy
{
  constexpr static float get_threshold() noexcept { return 1.5; }

  template<typename SizeType, typename TableStyle>
  struct rebind
    : public load_factor_rehash<SizeType, TableStyle,
				default_rehash_policy>
  {
  };
};

/**
 * policy: load factor rehash with custom threshold
 *
 * NOTE: threshold value is specified by deriving from this class
 * using CRTP and providing a get_threshold() function in the derived
 * class.
 */
template<typename Derived>
struct custom_threshold_rehash_policy : rehash_tag
{
  constexpr static float
  get_threshold() noexcept
  {
    return Derived::get_threshold();
  }

  template<typename SizeType, typename TableStyle>
  struct rebind
    : public load_factor_rehash<SizeType, TableStyle, Derived>
  {
  };
};

/**
 * policy: never rehash the table
 */
struct no_rehash_policy : rehash_tag
{
  template<typename SizeType, typename TableStyle>
  struct rebind
  {
    using CheckResult = RehashCheckResult<SizeType>;

    static float
    max_load_factor()
    {
      return std::numeric_limits<float>::max();
    }

    static CheckResult
    rehash_check(SizeType current_bucket_count,
		 SizeType next_entry_count)
    {
      return std::experimental::nullopt;
    }
  };
};

// ***** bucket container policies *****

/**
 * default policy: bucket container is std::vector
 */
struct default_bucket_container_policy
{
  template <typename ValueType, typename AllocPolicy>
  struct rebind
  {
    // rebind via allocator policy
    using type =
      typename AllocPolicy::template rebind<ValueType, std::vector>::type;
  };
};

/**
 * policy: bucket container is std::list
 */
struct std_list_bucket_container_policy : bucket_container_tag
{
  template <typename ValueType, typename AllocPolicy>
  struct rebind
  {
    // rebind via allocator policy
    using type =
      typename AllocPolicy::template rebind<ValueType, std::list>::type;
  };
};

// @todo add custom container policy choice

namespace detail
{

// ********** policy binder definitions **********

// ***** key extractor policy  binder *****

DEFINE_POLICY_BINDER(key_extractor_policy_binder,
		     default_key_extractor_policy,
		     key_extractor_tag);

// ***** predicate policy  binder *****

DEFINE_POLICY_BINDER(predicate_policy_binder,
		     default_predicate_policy,
		     predicate_tag);

// ***** allocator policy binder *****

DEFINE_POLICY_BINDER(allocator_policy_binder,
		     default_allocator_policy,
		     allocator_tag);

// ***** hash function policy binder *****

DEFINE_POLICY_BINDER(hash_function_policy_binder,
		     default_hash_policy,
		     hash_function_tag);

// ***** table length style policy binder *****

DEFINE_POLICY_BINDER(table_length_policy_binder,
		     default_table_length_policy,
		     table_length_tag);

// ***** rehash policy binder *****

DEFINE_POLICY_BINDER(rehash_policy_binder,
		     default_rehash_policy,
		     rehash_tag);

// ***** bucket container type policy binder *****

DEFINE_POLICY_BINDER(bucket_container_policy_binder,
		     default_bucket_container_policy,
		     bucket_container_tag);

} // namespace detail

/**
 * Policy-based hash_set container.
 *
 * @todo full documentation of available policies
 */
template<typename ValueType, typename... Policies>
class hash_set
{
  // policy configurations
  using KeyExtractorBinding = detail::key_extractor_policy_binder<Policies...>;
  using PredicateBinding = detail::predicate_policy_binder<Policies...>;
  using AllocatorBinding = detail::allocator_policy_binder<Policies...>;
  using HashFunctionBinding = detail::hash_function_policy_binder<Policies...>;
  using TableLengthBinding = detail::table_length_policy_binder<Policies...>;
  using RehashBinding = detail::rehash_policy_binder<Policies...>;
  using BucketContainerBinding =
    detail::bucket_container_policy_binder<Policies...>;

  using KeyExtractorPolicy = typename KeyExtractorBinding::type;
  using PredicatePolicy = typename PredicateBinding::type;
  using AllocatorPolicy = typename AllocatorBinding::type;
  using HashFunctionPolicy = typename HashFunctionBinding::type;
  using TableLengthPolicy = typename TableLengthBinding::type;
  using RehashPolicy = typename RehashBinding::type;
  using BucketContainerPolicy = typename BucketContainerBinding::type;

  using PolicyBindCounter =
    jrl::policy_bind_counter<KeyExtractorBinding,
			     PredicateBinding,
			     AllocatorBinding,
			     HashFunctionBinding,
			     TableLengthBinding,
			     RehashBinding,
			     BucketContainerBinding>;

  // policy configuration check: the length of the policy template
  // pack must equal the number of matched policies.
  static_assert((sizeof...(Policies) == PolicyBindCounter::value),
		"extraneous type specified in hash_table policies");

  // rebind parameterized policies
  using BucketType =
    typename BucketContainerPolicy::template rebind<ValueType,
						    AllocatorPolicy>::type;
  using TableType =
    typename AllocatorPolicy::template rebind<BucketType, std::vector>::type;
  using Extractor =
    typename KeyExtractorPolicy::template rebind<ValueType>;
  using Predicate =
    typename PredicatePolicy::template rebind<typename Extractor::key_type>;
  using TableLength =
    typename TableLengthPolicy::template rebind<typename TableType::size_type>;
  using Hasher =
    typename HashFunctionPolicy::template rebind<typename Extractor::key_type,
						 typename TableType::size_type>;
  using Rehasher =
    typename RehashPolicy::template rebind<typename TableType::size_type,
					   TableLength>;

  // useful alias for this type
  using HashSetType = hash_set<ValueType, Policies...>;

public:
  using key_type = typename Extractor::key_type;
  using value_type = ValueType;
  using size_type = typename TableType::size_type;

  // @todo iterator will be different (modified TableIterator) for
  // open addressing
  template<bool IsConst>
  class IteratorImpl
    : public boost::iterator_facade<IteratorImpl<IsConst>,
				    SELECTIVE_CONST(IsConst, value_type),
				    std::forward_iterator_tag>
  {
    // type used for the table pointer that is stored in the iterator
    using ItrTableType = SELECTIVE_CONST(IsConst, TableType);
    using TableIterator =
      typename std::conditional<IsConst,
				typename TableType::const_iterator,
				typename TableType::iterator>::type;
    using BucketIterator =
      typename std::conditional<IsConst,
				typename BucketType::const_iterator,
				typename BucketType::iterator>::type;
  public:
    DEFAULT_CONSTRUCTABLE(IteratorImpl);
    DEFAULT_COPYABLE(IteratorImpl);
    DEFAULT_MOVEABLE(IteratorImpl);

    explicit IteratorImpl(ItrTableType *table)
      : table_(table), tblItr_(table->begin()),
      	bktItr_(std::begin(*tblItr_))
    {
      if (tblItr_->empty()) {
	// call increment to find the first valid bucket
	increment();
      }
    }

    IteratorImpl(ItrTableType *table, size_type tblIdx, BucketIterator &&bktItr)
      : table_(table), tblItr_(table_->begin() + tblIdx), bktItr_(std::move(bktItr))
    {
    }

    IteratorImpl(ItrTableType *table, TableIterator tblItr,
		 BucketIterator &&bktItr)
      : table_(table), tblItr_(tblItr), bktItr_(std::move(bktItr))
    {
    }

  private:
    friend class hash_set<ValueType, Policies...>;
    friend class boost::iterator_core_access;
    using Type = IteratorImpl<IsConst>;

#   define SANITY_CHECK()					\
    do {							\
      assert((nullptr == table_) ||				\
	     (table_->end() != tblItr_) ||			\
	     (std::end(*tblItr_) != bktItr_));			\
    } while(0)

    void
    increment()
    {
      SANITY_CHECK();
      // if the bucket index can be incremented by 1 and remain lower
      // than the bucket size then the next entry is in the current
      // bucket, increment the index and return
      if (std::end(*tblItr_) != bktItr_) {
	BucketIterator cpy(bktItr_);
	++cpy;
	if (std::end(*tblItr_) != cpy) {
	  ++bktItr_;
	  return;
	}
      }
      // skip over empty buckets
      do {
	++tblItr_;
      } while ((table_->end() != tblItr_) && tblItr_->empty());
      // check for end of iteration
      if (tblItr_ != table_->end()) {
	// current bucket contains the next valid entry
	bktItr_ = std::begin(*tblItr_);
	return;
      }
      // no valid entries remaining
      *this = Type();
    }

    bool
    equal(const Type &that) const
    {
      SANITY_CHECK();
      return (table_ == that.table_) &&
	(tblItr_ == that.tblItr_) &&
	(bktItr_ == that.bktItr_);
    }

#   undef SANITY_CHECK

    ValueType &
    dereference() const
    {
      return *bktItr_;
    }

    size_type
    getBucketIndex() const
    {
      return std::distance(std::begin(*table_), tblItr_);
    }

    BucketIterator
    getBucketIterator() const
    {
      return bktItr_;
    }

    ItrTableType *table_;
    TableIterator tblItr_;
    BucketIterator bktItr_;
  };

  using iterator = IteratorImpl<false>;
  using const_iterator = IteratorImpl<true>;

  hash_set()
    : table_(move(make_initial_table())), entry_count_(0)
  {
  }

  DEFAULT_COPYABLE(hash_set);
  DEFAULT_MOVEABLE(hash_set);
  DEFAULT_DESTRUCTABLE(hash_set);

  bool
  empty() const noexcept
  {
    return 0 == entry_count_;
  }

  size_type
  size() const noexcept
  {
    return entry_count_;
  }

  // size_type
  // max_size() const noexcept
  // {
  //   // @todo
  // }

  size_type
  buckets() const
  {
    return table_.size();
  }

  iterator
  begin()
  {
    return iterator(&table_);
  }

  const_iterator
  begin() const
  {
    return const_iterator(&table_);
  }

  iterator
  end()
  {
    return iterator();
  }

  const_iterator
  end() const
  {
    return const_iterator();
  }

  const_iterator
  cbegin() const
  {
    return const_iterator(&table_);
  }

  const_iterator
  cend() const
  {
    return const_iterator();
  }

  template<typename... Args>
  std::pair<iterator, bool>
  emplace(Args &&... args)
  {
    if (Extractor::can_get_key_from_constructor) {
      return emplace_internal(DO_NOT_OVERWRITE, std::forward<Args>(args)...);
    }
    return emplace_internal(DO_NOT_OVERWRITE,
			    value_type(std::forward<Args>(args)...));
  }

  template<typename... Args>
  iterator
  emplace_hint(const_iterator hint, Args &&... args)
  {
    auto keyResult = get_key_from_raw(std::forward<Args>(args)...);
    const auto &argsKey = keyResult.first;
    if (cend() != hint) {
      // check if hint iterator points to an existing entry that can
      // be overwritten
      BucketIterator bktItr =
	remove_iterator_constness(const_cast<BucketType &>(*(hint.tblItr_)),
				  hint.bktItr_);
      const auto &hintKey = Extractor::get_key(*bktItr);
      if (argsKey == hintKey) {
	// hint iterator points to the correct position, overwrite any
	// value that currently exists
	TableType *tbl = const_cast<TableType *>(hint.table_);
	TableIterator tItr(remove_iterator_constness(table_, hint.tblItr_));
	iterator ins(tbl, tItr, std::move(bktItr));
	*ins = value_type(std::forward<Args>(args)...);
	return ins;
      }
      // fall through to logic that does not use the hint
    }

    // hint is useless
    auto &val(keyResult.second);
    if (val) {
      // cannot extract key from constructor arguments
      const auto result = emplace_internal(DO_OVERWRITE, std::move(*val));
      return result.first;
    }
    const auto result =
      emplace_internal(DO_OVERWRITE, std::forward<Args>(args)...);
    return result.first;
  }

  std::pair<iterator, bool>
  insert(const ValueType &value)
  {
    auto fiResult = find_internal(Extractor::get_key(value));
    {
      auto entry = fiResult.first;
      if (std::end(*this) != entry) {
	// entry already exists
	return std::make_pair(entry, UNSUCCESSFUL_ADD);
      }
    }

    // @todo use RAII to restore original state on exception ??

    // entry does not yet exist, insert it

    // rehash, if necessary
    const auto new_bucket_count =
      Rehasher::rehash_check(buckets(), size() + 1);
    if (new_bucket_count) {
      return std::make_pair(rehash_internal(*new_bucket_count, value),
			    SUCCESSFUL_ADD);
    }
    size_type idx = fiResult.second;
    BucketType &bucket(table_.at(idx));
    auto itr = bucket.insert(std::end(bucket), value);
    ++entry_count_;
    return std::make_pair(iterator(&table_, idx, std::move(itr)),
			  SUCCESSFUL_ADD);
  }

  // std::pair<iterator, bool>
  // insert(ValueType &&value)
  // {
  //   // @todo
  // }

  // iterator
  // insert(const_iterator hint, const ValueType &value)
  // {
  //   // @todo
  // }

  // iterator
  // insert(const_iterator hint, ValueType &&value)
  // {
  //   // @todo
  // }

  // template<typename InputIterator>
  // void
  // insert(InputIterator first, InputIterator last)
  // {
  //   // @todo
  // }

  // void
  // insert(initializer_list<value_type> init)
  // {
  //   // @todo
  // }

  iterator
  erase(const const_iterator &pos)
  {
    return erase_common(pos);
  }

  iterator
  erase(const iterator &pos)
  {
    return erase_common(pos);
  }

  // @todo unordered_set interface actually takes key_type argument
  size_type
  erase(const ValueType &val)
  {
    auto entry = find(val);
    if (end() != entry) {
      // found the element
      entry.tblItr_->erase(entry.bktItr_);
      --entry_count_;
      return 1;
    }
    // no such element
    return 0;
  }

  // iterator
  // erase(const_iterator first, const_iterator last)
  // {
  //   // @todo
  // }

  void
  clear()
  {
    TableType empty(move(make_initial_table()));
    table_.swap(empty);
    entry_count_ = 0;
  }

  void
  swap(hash_set &tgt)
  {
    table_.swap(tgt.table_);
    std::swap(entry_count_, tgt.entry_count_);
  }

  // hasher
  // hash_function() const
  // {
  //   // @todo
  // }

  // key_equal
  // key_eq() const
  // {
  //   // @todo
  // }

  inline iterator
  find(const key_type &key)
  {
    auto result = find_internal(key);
    return result.first;
  }

  inline const_iterator
  find(const key_type &key) const
  {
    auto result = find_internal(key);
    return result.first;
  }

  size_type
  count(const key_type &key) const
  {
    // @todo not suitable for multi set/map
    auto entry = find_internal(key);
    if (end() == entry.first) {
      return 0;
    }
    return 1;
  }

  // std::pair<iterator, iterator>
  // equal_range(const key_type &key)
  // {
  //   // @todo
  // }

  // std::pair<const_iterator, const_iterator>
  // equal_range(const key_type &key)
  // {
  //   // @todo
  // }

  inline size_type
  bucket_count() noexcept
  {
    return table_.size();
  }

  // size_type
  // max_bucket_count() const noexcept
  // {
  //   // @todo
  // }

  inline size_type
  bucket_size(size_type idx) const
  {
    return table_[idx].size();
  }

  inline size_type
  bucket(const ValueType &value) const
  {
    return TableLength::hash_to_bucket(Hasher()(Extractor::get_key(value)),
				       buckets());
  }

  // local_iterator
  // begin(size_type idx)
  // {
  //   // @todo
  // }

  // const_local_iterator
  // begin(size_type idx) const
  // {
  //   // @todo
  // }

  // const_local_iterator
  // cbegin(size_type idx) const
  // {
  //   // @todo
  // }

  // local_iterator
  // end(size_type idx)
  // {
  //   // @todo
  // }

  // const_local_iterator
  // end(size_type idx) const
  // {
  //   // @todo
  // }

  // const_local_iterator
  // cend(size_type idx) const
  // {
  //   // @todo
  // }

  inline float
  load_factor() const noexcept
  {
    return load_factor(entry_count_);
  }

  float
  max_load_factor() const noexcept
  {
    return Rehasher::max_load_factor();
  }

  void
  rehash(const size_type new_bucket_count)
  {
    auto rehash_check_result =
      Rehasher::rehash_check(new_bucket_count, size());
    if ((rehash_check_result) && (buckets() != *rehash_check_result)) {
      rehash_internal(*rehash_check_result);
    }
  }

  // void
  // reserve(size_type sz)
  // {
  //   // @todo
  // }

private:
  using BucketIterator = typename BucketType::iterator;
  using BucketConstIterator = typename BucketType::const_iterator;
  using TableIterator = typename TableType::iterator;
  using TableConstIterator = typename TableType::const_iterator;
  using TableSearchResult =
    std::pair<std::experimental::optional<BucketIterator>, size_type>;

  /**
   * Helper class for the common operation of finding a key in a
   * container using the Predicate and Extractor policies.
   */
  // @todo see if KeyMatcher can be replaced by some combination of
  // std::bind and std::equal_to
  class KeyMatcher
  {
  public:
    KeyMatcher(const key_type &key)
      : key_(key)
    {
    }

    bool
    operator()(const value_type &entry)
    {
      return Predicate()(key_, Extractor::get_key(entry));
    }

  private:
    const key_type &key_;
  };

  /**
   * Extract the key for a value from raw constructor arguments.
   *
   * NOTE: this process may require construction of the value_type
   * object, which is done in a way that allows it to be efficiently
   * reused by subsequent code.
   *
   * @return the extracted key in the first element of the pair,
   * second element is true if a value object has been constructed in
   * the output parameter val (i.e. if
   * Extractor::can_get_key_from_constructor is false), or false
   * otherwise.
   */
  template<typename... Args>
  std::pair<const key_type &, std::experimental::optional<value_type>>
  get_key_from_raw(Args &&... args)
  {
    if (Extractor::can_get_key_from_constructor) {
      return std::make_pair(Extractor::key_from_ctor_args(std::forward<Args>(args)...),
			    std::experimental::nullopt);
    }
    value_type val(value_type(std::forward<Args>(args)...));
    return std::make_pair(Extractor::get_key(val), std::move(val));
  }

  /**
   * Helper function for constructing the table that handles correctly
   * setting the initial bucket count and default-constructing the
   * buckets
   */
  TableType
  make_initial_table()
  {
    return TableType(TableLength::initial_bucket_count(), BucketType());
  }

  float
  load_factor(size_t entry_count) const noexcept
  {
    assert(table_.size() > 0);
    return static_cast<float>(entry_count) / static_cast<float>(table_.size());
  }

  /**
   * Find a value in the set.
   *
   * @return a pair of values, the first being an iterator that
   *         references the position of an entry having the same key
   *         as the argument (equal to end() if no such entry exists
   *         in the set), and the second being the bucket index
   *         generated by the key.
   */
  std::pair<const_iterator, size_type>
  find_internal(const key_type &key) const
  {
    size_type idx = TableLength::hash_to_bucket(Hasher()(key), buckets());
    const TableType *table(&table_);
    auto &bucket(table->at(idx));
    auto entry =
      find_if(std::begin(bucket), std::end(bucket), KeyMatcher(key));
    if (std::end(bucket) == entry) {
      return std::make_pair(const_iterator(), idx);
    }
    return std::make_pair(const_iterator(table, idx, std::move(entry)), idx);
  }

  /**
   * Find a value in the set.
   *
   * @return a pair of values, the first being an iterator that
   *         references the position of an entry having the same key
   *         as the argument (equal to end() if no such entry exists
   *         in the set), and the second being the bucket index
   *         generated by the key.
   */
  std::pair<iterator, size_type>
  find_internal(const key_type &key)
  {
    size_type idx = TableLength::hash_to_bucket(Hasher()(key), buckets());
    TableType *table(&table_);
    auto &bucket(table->at(idx));
    auto entry =
      find_if(std::begin(bucket), std::end(bucket), KeyMatcher(key));
    if (std::end(bucket) == entry) {
      return std::make_pair(iterator(), idx);
    }
    return std::make_pair(iterator(table, idx, std::move(entry)), idx);
  }

  template<typename... Args>
  std::pair<iterator, bool>
  emplace_internal(const bool isOverwriteExistingEntry, Args &&... args)
  {
    const auto &argsKey = Extractor::key_from_ctor_args(std::forward<Args>(args)...);
    const auto fiResult = find_internal(argsKey);
    const auto entry = fiResult.first;
    const auto idx = fiResult.second;
    if (end() == entry) {
      // entry does not yet exist, add it
      const auto newBucketCount =
	Rehasher::rehash_check(buckets(), size() + 1);
      if (newBucketCount) {
	// needs rehash
	return std::make_pair(rehash_internal(*newBucketCount,
					      std::forward<Args>(args)...),
			      SUCCESSFUL_ADD);
      }
      // no rehash
      return std::make_pair(emplace_at_index(table_, idx, DO_INCREMENT,
					     std::forward<Args>(args)...),
			    SUCCESSFUL_ADD);
    }
    // entry already exists
    if (isOverwriteExistingEntry) {
      *entry = value_type(std::forward<Args>(args)...);
      // NOTE: the second element of the result pair is extraneous
      // here, this is the case where emplace_internal is being used
      // within emplace_hint, which will simply extract the first
      // element for return
      return std::make_pair(entry, SUCCESSFUL_ADD);
    }
    // return iterator to the entry
    return std::make_pair(entry, UNSUCCESSFUL_ADD);
  }

  std::pair<iterator, bool>
  emplace_internal(const bool isOverwriteExistingEntry, value_type &&val)
  {
    const auto &argsKey = Extractor::get_key(val);
    const auto fiResult = find_internal(argsKey);
    const auto entry = fiResult.first;
    const auto idx = fiResult.second;
    if (end() == entry) {
      // entry does not yet exist, add it
      const auto newBucketCount =
	Rehasher::rehash_check(buckets(), size() + 1);
      if (newBucketCount) {
	// needs rehash
	return std::make_pair(rehash_internal(*newBucketCount, std::move(val)),
			      SUCCESSFUL_ADD);
      }
      // no rehash
      return std::make_pair(emplace_at_index(table_, idx, DO_INCREMENT,
					     std::move(val)),
			    SUCCESSFUL_ADD);
    }
    // entry already exists
    if (isOverwriteExistingEntry) {
      *entry = std::move(val);
      // NOTE: the second element of the result pair is extraneous
      // here, this is the case where emplace_internal is being used
      // within emplace_hint, which will simply extract the first
      // element for return
      return std::make_pair(entry, SUCCESSFUL_ADD);
    }
    // return iterator to the entry
    return std::make_pair(entry, UNSUCCESSFUL_ADD);
  }

  static iterator
  insert_one(TableType &table, const size_type buckets, const value_type &val)
  {
    const auto &key = Extractor::get_key(val);
    size_type idx = TableLength::hash_to_bucket(Hasher()(key), buckets);
    BucketType &bucket(table.at(idx));
    return iterator(&table, idx, bucket.insert(std::end(bucket), val));
  }

  iterator
  emplace_at_index(TableType &table, const size_type idx,
		   const bool isIncrementEntryCount, value_type &&val)
  {
    BucketType &bucket(table.at(idx));
    auto bktItr = bucket.emplace(std::end(bucket), std::move(val));
    // exception safety: increment entry_count_ after emplacing in the bucket
    if (isIncrementEntryCount) {
      ++entry_count_;
    }
    return iterator(&table, idx, std::move(bktItr));
  }

  template<typename... Args>
  iterator
  emplace_at_index(TableType &table, const size_type idx,
		   const bool isIncrementEntryCount, Args &&... args)
  {
    BucketType &bucket(table.at(idx));
    auto bktItr = bucket.emplace(std::end(bucket), std::forward<Args>(args)...);
    // exception safety: increment entry_count_ after emplacing in the bucket
    if (isIncrementEntryCount) {
      ++entry_count_;
    }
    return iterator(&table, idx, std::move(bktItr));
  }

  iterator
  emplace_one(TableType &table, const size_type buckets, value_type &&val)
  {
    const auto &key = Extractor::get_key(val);
    size_type idx = TableLength::hash_to_bucket(Hasher()(key), buckets);
    return emplace_at_index(table, idx, DO_NOT_INCREMENT, std::move(val));
  }

  template<typename... Args>
  iterator
  emplace_one(TableType &table, const size_type buckets, Args &&... args)
  {
    // @todo static_assert here?
    assert(Extractor::can_get_key_from_constructor);
    const key_type &key =
      Extractor::key_from_ctor_args(std::forward<Args>(args)...);
    size_type idx = TableLength::hash_to_bucket(Hasher()(key), buckets);
    return emplace_at_index(table, idx, DO_NOT_INCREMENT,
			    std::forward<Args>(args)...);
  }

  void
  copy_table(TableType &table, const size_type buckets)
  {
    // @todo is the check against is_move_constructible necessary
    // here, or will the code default to the correct behavior if move
    // semantics are not available for the type?  Need to create a
    // test case and also review the standard
    if (std::is_move_constructible<value_type>::value) {
      for (auto &&entry : *this) {
	emplace_one(table, buckets, std::move(entry));
      }
    }
    else {
      for (const auto &entry : *this) {
	insert_one(table, buckets, entry);
      }
    }
  }

  void
  rehash_internal(const size_type new_bucket_count)
  {
    TableType new_table(new_bucket_count, BucketType());
    copy_table(new_table, new_bucket_count);
    table_.swap(new_table);
  }

  iterator
  rehash_internal(const size_type new_bucket_count,
		  const value_type &val)
  {
    TableType new_table(new_bucket_count, BucketType());
    copy_table(new_table, new_bucket_count);
    iterator result = insert_one(new_table, new_bucket_count, val);
    ++entry_count_;
    table_.swap(new_table);
    // @todo does swap() invalidate the iterators?
    return iterator(&table_, result.getBucketIndex(),
		    result.getBucketIterator());
  }

  iterator
  rehash_internal(const size_type new_bucket_count,
		  value_type &&val)
  {
    TableType new_table(new_bucket_count, BucketType());
    copy_table(new_table, new_bucket_count);
    iterator result = emplace_one(new_table, new_bucket_count, std::move(val));
    ++entry_count_;
    table_.swap(new_table);
    // @todo does swap() invalidate the iterators?
    return iterator(&table_, result.getBucketIndex(),
		    result.getBucketIterator());
  }

  template<typename... Args>
  iterator
  rehash_internal(const size_type new_bucket_count,
		  Args &&... args)
  {
    TableType new_table(new_bucket_count, BucketType());
    copy_table(new_table, new_bucket_count);
    iterator result =
      emplace_one(new_table, new_bucket_count, std::forward<Args>(args)...);
    ++entry_count_;
    table_.swap(new_table);
    // @todo does swap() invalidate the iterators?
    return iterator(&table_, result.getBucketIndex(),
		    result.getBucketIterator());
  }

  // @todo delegate to the addressing policy
  template<bool IsConst>
  iterator
  erase_common(const IteratorImpl<IsConst> &pos)
  {
    // sanity check
    assert(&table_ == pos.table_);
    assert(end() != pos);

    // erase the entry pointed to by the iterator
    auto bktItr = pos.tblItr_->erase(pos.bktItr_);
    --entry_count_;

    // find the next valid entry and return an iterator to it
    if (std::end(*(pos.tblItr_)) != bktItr) {
      // some subsequent element remains in this bucket
      return iterator(&table_, pos.tblItr_, move(bktItr));
    }
    // last entry in the bucket
    auto tblItr = pos.tblItr_;
    ++tblItr;
    if (std::end(table_) == tblItr) {
      // no more buckets
      return iterator();
    }
    iterator result(&table_, tblItr, std::begin(*tblItr));
    // NOTE: result may be invalid because the subsequent bucket is
    // empty, call increment() to ensure that it is valid
    result.increment();
    return result;
  }

  TableType table_;
  size_type entry_count_;
};

} // namespace jrl

#endif // JRL_UTIL_HASH_SET_GUARD
