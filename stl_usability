/** -*- mode: c++ -*-
 *
 * stl_usability
 *
 * Copyright (C) 2015 Brian Davis
 * All Rights Reserved
 *
 * \TODO new license
 *
 * Limited copying permission is given solely
 * for self-educational purpose.
 *
 * Author: Brian Davis <bd@jollyrogerlabs.com>
 *
 * Header-only definitions to simplify use of STL.
 */

#ifndef STL_USABILITY_GUARD
#define STL_USABILITY_GUARD

#include <algorithm>

namespace jrl
{

// Convenience macros for results.
#define CONST_ITER typename _Container::const_iterator
#define OUT_ITER _OutputIterator
#define UNARY_OUT _Unary
#define CONST_TYPE const
#define NO_CONST_TYPE /* not const */

// Algorithms that iterate over a range.
#define NO_OP(name, result)					\
  template<class _Container>					\
  inline result							\
  name(const _Container &__container)				\
  {								\
    return std::name(__container.begin(), __container.end());	\
  }

/**
 * Sort an array by its natural ordering (AKA default less<>).
 */
NO_OP(sort, CONST_ITER)

#undef NO_OP

// Algorithms that iterate over a range applying a unary operator to
// each element.
#define UNARY_OP(name, result)						\
  template<class _Container, typename _Unary>				\
  inline result								\
  name(const _Container &__container,  _Unary __unary)			\
  {									\
    return std::name(__container.begin(), __container.end(), __unary);	\
  }

/**
 * Copy all container entries.
 */
UNARY_OP(copy, UNARY_OUT)
/**
 * Iterate over all elements of a container, applying a unaery
 * operator to each.
 */
UNARY_OP(for_each, UNARY_OUT)
/**
 * Find the first occurrence of a value.
 */
UNARY_OP(find, CONST_ITER)
UNARY_OP(find_if, CONST_ITER)

#undef UNARY_OP

// Algorithms that iterate over a range applying an operator to each
// element and storing the result of that application to a container.
#define UNARY_OP_OUT(name, result)					\
  template<class _Container, typename _OutputIterator, typename _Unary>	\
  inline result								\
  name(const _Container &__container, _OutputIterator __result,		\
       _Unary __unary)							\
  {									\
    return std::name(__container.begin(), __container.end(), __result,	\
		     __unary);						\
  }

/**
 * Transform all container entries (AKA "map")
 */
UNARY_OP_OUT(transform, OUT_ITER)
/**
 * Copy all items that satisfy a predicate
 */
UNARY_OP_OUT(copy_if, OUT_ITER)

#undef UNARY_OP_OUT

#define BINARY_OP(name, result, const_type)				\
  template<class _Container, typename _Binary>				\
  inline result								\
  name(const_type _Container &__container, _Binary __binary)		\
  {									\
    return std::name(__container.begin(), __container.end(), __binary);	\
  }

/**
 * Sort an array using a binary comparison operator.
 */
BINARY_OP(sort, void, NO_CONST_TYPE)

#undef BINARY_OP

#define SEARCH_OP(name)							\
  template<class _Container, typename _SearchType, typename _Binary>	\
  inline typename _Container::iterator					\
  name(const _Container &__container, const _SearchType &__val,		\
       _Binary __binary)						\
  {									\
    return std::name(__container.begin(), __container.end(), __val,	\
		     __binary);						\
  }

/**
 * Find the first position in which an argument value can be inserted
 * without changing the ordering.
 */
SEARCH_OP(lower_bound);
SEARCH_OP(upper_bound);

#undef SEARCH_OP

#define PAIRWISE_BINARY_OP_OUT(name, result)				\
  template<typename _Container1, typename _Container2,			\
	   typename _OutputIterator, typename _Binary>			\
  inline result								\
  name(const _Container1 &__container1, const _Container2 &__container2, \
       _OutputIterator __result, _Binary __binary)			\
  {									\
    return std::name(__container1.begin(), __container1.end(),		\
		     __container2.begin(), __result, __binary);		\
  }

/**
 * Transform the mixture of two containers.
 */
PAIRWISE_BINARY_OP_OUT(transform, OUT_ITER)

#undef PAIRWISE_BINARY_OP_OUT

#undef CONST_ITER
#undef OUT_ITER
#undef UNARY_OUT
#undef CONST_TYPE
#undef NO_CONST_TYPE

} // namespace jrl

#endif // STL_USABILITY_GUARD
