/** -*- mode: c++ -*-
 *
 * stl_usability
 *
 * Header-only definitions to simplify use of STL.
 *
 * Copyright (C) 2015 Brian Davis
 * All Rights Reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: Brian Davis <bd@jollyrogerlabs.com>
 *
 */

#if !defined(STL_USABILITY_GUARD)
#define STL_USABILITY_GUARD

#include <algorithm>

namespace jrl
{

enum {
  // enum to be used for accessing the key from a value_type object of
  // a map-like container
  KEY = 0,
  VALUE = 1,
  // enum to be used for accessing the result of calling insert() on a
  // map-like container
  ENTRY = 0,
  INSERT_RESULT = 1
};

/**
 * Helper function for the case where an element should only be
 * inserted if not already present; this function should be called
 * prior to the insert to determine if the key is present.
 */
template<typename _MapOrSetType>
inline bool
is_present(const _MapOrSetType &__mapOrSet,
	   const typename _MapOrSetType::key_type &__key)
{
  return std::end(__mapOrSet) != __mapOrSet.find(__key);
}

// Convenience macros for results.
#define ITER typename _Container::iterator
#define CONST_ITER typename _Container::const_iterator
#define OUT_ITER _OutputIterator
#define UNARY_OUT _Unary
#define CONST_TYPE const
#define NO_CONST_TYPE /* not const */

// Algorithms that iterate over a range.
#define NO_OP(name, ResultType, ConstSpec)				\
  template<class _Container>						\
  inline ResultType							\
  name(ConstSpec _Container &__container)				\
  {									\
    return std::name(begin(__container), std::end(__container));	\
  }

/**
 * Sort an array by its natural ordering (AKA default less<>).
 */
NO_OP(sort, void, NO_CONST_TYPE)

#undef NO_OP

// Algorithms that iterate over a range applying a unary operator to
// each element.
#define UNARY_OP(name, ResultType, ConstSpec)				\
  template<class _Container, typename _Unary>				\
  inline ResultType							\
  name(ConstSpec _Container &__container,  _Unary __unary)		\
  {									\
    return std::name(begin(__container), std::end(__container), __unary); \
  }

/**
 * Copy all container entries.
 */
UNARY_OP(copy, UNARY_OUT, CONST_TYPE)
/**
 * Iterate over all elements of a container, applying a unary
 * operator to each.
 */
UNARY_OP(for_each, UNARY_OUT, CONST_TYPE)
/**
 * Find the first occurrence of a value.
 */
UNARY_OP(find, CONST_ITER, CONST_TYPE)
UNARY_OP(find, ITER, NO_CONST_TYPE)
UNARY_OP(find_if, CONST_ITER, CONST_TYPE)
UNARY_OP(find_if, ITER, NO_CONST_TYPE)
/**
 * Remove all items that compare equal to an argument value
 */
UNARY_OP(remove, ITER, NO_CONST_TYPE)
/**
 * Remove all items that satisfy a predicate
 */
UNARY_OP(remove_if, ITER, NO_CONST_TYPE)

#undef UNARY_OP

// Algorithms that iterate over a range applying an operator to each
// element and storing the result of that application to a container.
#define UNARY_OP_OUT(name, ResultType, ConstSpec)			\
  template<class _Container, typename _OutputIterator, typename _Unary>	\
  inline ResultType							\
  name(ConstSpec _Container &__container, _OutputIterator __result,	\
       _Unary __unary)							\
  {									\
    return std::name(std::begin(__container), std::end(__container), __result, \
		     __unary);						\
  }

/**
 * Transform all container entries (AKA "map")
 */
UNARY_OP_OUT(transform, OUT_ITER, NO_CONST_TYPE)
/**
 * Copy all items that satisfy a predicate
 */
UNARY_OP_OUT(copy_if, OUT_ITER, CONST_TYPE)

#undef UNARY_OP_OUT

#define BINARY_OP(name, ResultType, ConstSpec)				\
  template<class _Container, typename _Binary>				\
  inline ResultType							\
  name(ConstSpec _Container &__container, _Binary __binary)		\
  {									\
    return std::name(std::begin(__container), std::end(__container), __binary);	\
  }

/**
 * Sort an array using a binary comparison operator.
 */
BINARY_OP(sort, void, NO_CONST_TYPE)

#undef BINARY_OP

#define SEARCH_OP(name)							\
  template<class _Container, typename _SearchType, typename _Binary>	\
  inline typename _Container::iterator					\
  name(const _Container &__container, const _SearchType &__val,		\
       _Binary __binary)						\
  {									\
    return std::name(std::begin(__container), std::end(__container), __val, \
		     __binary);						\
  }

/**
 * Find the first position in which an argument value can be inserted
 * without changing the ordering.
 */
SEARCH_OP(lower_bound);
SEARCH_OP(upper_bound);

#undef SEARCH_OP

#define PAIRWISE_BINARY_OP_OUT(name, ResultType)			\
  template<typename _Container1, typename _Container2,			\
	   typename _OutputIterator, typename _Binary>			\
  inline ResultType							\
  name(const _Container1 &__container1, const _Container2 &__container2, \
       _OutputIterator __result, _Binary __binary)			\
  {									\
    return std::name(std::begin(__container1), std::end(__container1),	\
		     std::begin(__container2), __result, __binary);	\
  }

/**
 * Transform the mixture of two containers.
 */
PAIRWISE_BINARY_OP_OUT(transform, OUT_ITER)

#undef PAIRWISE_BINARY_OP_OUT

#undef CONST_ITER
#undef OUT_ITER
#undef UNARY_OUT
#undef CONST_TYPE
#undef NO_CONST_TYPE

/**
 * Move all elements (potentially destructively) from source
 * container/range to target.
 */
template<typename _Container, typename _OutputIterator>
inline _OutputIterator
move_all(_Container &__src, _OutputIterator __tgt)
{
  // \TODO
  // for (typename _Container::iterator entry = std::begin(__src);
  //      entry != std::end(__src); ++entry) {
  //   *__tgt = std::move(*entry);
  for (auto &entry : __src) {
    *__tgt = std::move(entry);
    ++__tgt;
  }
  return __tgt;
}

/**
 * @brief Turns assignment into insertion.
 *
 * These are output iterators, constructed from a container type,
 * assigning a instance of the containers value_type to the iterator
 * appends it to the container using emplace_back.
 *
 * Tip: Using the back_emplaceer function to create these iterators can
 * save typing.
 *
 * NOTE: Code stolen from gcc implementation of back_insert_iterator
 * and modified.
 */
template<typename _Container>
class back_emplace_iterator
  : public std::iterator<std::output_iterator_tag, void, void, void, void>
{
protected:
  _Container& container_;

public:
  using container_type = _Container;
  /// The only way to create this %iterator is with a target
  /// container.
  explicit
  back_emplace_iterator(_Container& __tgt) : container_(__tgt) { }

  /**
   * Emplace the value in the back of the container.
   *
   * @param __value an instance of whatever type
   *                container_type::value_type is
   * @return this %iterator, for chained operations.
   */
  back_emplace_iterator&
  operator=(typename _Container::value_type&& __value)
  {
    container_.emplace_back(std::move(__value));
    return *this;
  }

  /// noop
  back_emplace_iterator&
  operator*()
  {
    return *this;
  }

  /// noop
  back_emplace_iterator&
  operator++()
  {
    return *this;
  }

  /// noop
  back_emplace_iterator
  operator++(int)
  {
    return *this;
  }
};

/**
 * Helper function template for creating an instance of
 * back_emplace_operator.
 *
 * @param  __tgt  A container of arbitrary type.
 * @return An instance of back_emplace_iterator working on @p __tgt.
 */
template<typename _Container>
inline back_emplace_iterator<_Container>
back_emplacer(_Container& __tgt)
{
  return back_emplace_iterator<_Container>(__tgt);
}

/**
 * ostream_iterator with correct behavior for delimiters.
 *
 * In "innerate" mode, the delimiter is inserted BEFORE every element
 * EXCEPT the first one.  The internal flag which controls this
 * behavior is reset whenever the object is copy constructed, which
 * gives the correct behavior when passing an instance of
 * ostream_innerator to standard algorithms such as copy, transform,
 * etc.  The flag can also be reset by calling the reset() member
 * function.
 *
 * When not in "innerate" mode, the delimiter is inserted AFTER every
 * element just like ostream_iterator.
 */
template<typename _Tp, typename _CharT = char,
	 typename _Traits = std::char_traits<_CharT> >
class ostream_innerator
  : public std::iterator<std::output_iterator_tag, void, void, void, void>
{
public:
  using char_type = _CharT;
  using traits_type = _Traits;
  using ostream_type = std::basic_ostream<_CharT, _Traits>;

  /**
   * Construct from an ostream.
   *
   * NOTE: since there is no delimiter, "innerate" mode is irrelevant.
   */
  ostream_innerator(ostream_type &__tgt)
    : tgt_(&__tgt), delimiter_(0), innerate_(false), first_(false)
  {
  }

  /**
   * Construct from an ostream and delimiter.
   *
   * Insertion of The delimiter string @a delimiter is controlled by
   * the value of @a innerate.  The delimiter is not copied, and thus
   * must not be destroyed while this iterator is in use.
   *
   * @param __tgt Underlying ostream to write to.
   * @param __delimiter CharT delimiter string to insert.
   * @param __innerate if true, the delimiter is inserted before each
   *                   element except the first; otherwise, it is
   *                   inserted after each element.
   */
  ostream_innerator(ostream_type &__tgt, const char_type* __delimiter,
		    bool __innerate = true)
    : tgt_(&__tgt), delimiter_(__delimiter), innerate_(__innerate), first_(false)
  {
  }

  /// Copy constructor.
  ostream_innerator(const ostream_innerator &__src)
    : tgt_(__src.tgt_), delimiter_(__src.delimiter_),
      innerate_(__src.innerate_), first_(false)
  {
  }

  /// Writes @a val to underlying ostream using operator<<.  If
  /// constructed with delimiter string, writes delimiter to ostream.
  ostream_innerator&
  operator=(const _Tp &__val)
  {
    if (innerate_ && (nullptr != delimiter_)) {
      if (!first_) {
	first_ = true;
      }
      else {
	*tgt_ << delimiter_;
      }
    }
    *tgt_ << __val;
    if (!innerate_ && (nullptr != delimiter_)) {
      *tgt_ << delimiter_;
    }
    return *this;
  }

  /// noop
  ostream_innerator&
  operator*()
  {
    return *this;
  }

  /// noop
  ostream_innerator&
  operator++()
  {
    return *this;
  }

  /// noop
  ostream_innerator&
  operator++(int)
  {
    return *this;
  }

  /**
   * Explicitly reset the internal flag, which prevents the delimiter
   * from being printed before the next element passed to operator=.
   *
   * Call this function if using ostream_innerator in "innerate" mode
   * in an explicit loop instead of passing it to an algorithm.
   */
  void
  reset()
  {
    first_ = false;
  }

private:
  ostream_type* tgt_;
  const char_type* delimiter_;
  bool innerate_;
  bool first_;
  
};

} // namespace jrl

#endif // STL_USABILITY_GUARD
