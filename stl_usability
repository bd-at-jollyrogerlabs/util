/** -*- mode: c++ -*-
 *
 * stl_usability
 *
 * Header-only definitions to simplify use of STL.
 *
 * Copyright (C) 2015 Brian Davis
 * All Rights Reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: Brian Davis <bd@jollyrogerlabs.com>
 *
 */

#if !defined(STL_USABILITY_GUARD)
#define STL_USABILITY_GUARD

#include <algorithm>

namespace jrl
{

enum {
  // enum to be used for accessing the key from a value_type object of
  // a map-like container
  KEY = 0,
  VALUE = 1,
  // enum to be used for accessing the result of calling insert() on a
  // map-like container
  ENTRY = 0,
  INSERT_RESULT = 1
};

/**
 * Helper function for the case where an element should only be
 * inserted if not already present; this function should be called
 * prior to the insert to determine if the key is present.
 */
template<typename _MapOrSetType>
inline bool
is_present(const _MapOrSetType &__mapOrSet,
	   const typename _MapOrSetType::key_type &__key)
{
  return end(__mapOrSet) != __mapOrSet.find(__key);
}

// Convenience macros for results.
#define ITER typename _Container::iterator
#define CONST_ITER typename _Container::const_iterator
#define OUT_ITER _OutputIterator
#define UNARY_OUT _Unary
#define CONST_TYPE const
#define NO_CONST_TYPE /* not const */

// Algorithms that iterate over a range.
#define NO_OP(name, result_type, const_type)			\
  template<class _Container>					\
  inline result_type						\
  name(const_type _Container &__container)			\
  {								\
    return std::name(begin(__container), end(__container));	\
  }

/**
 * Sort an array by its natural ordering (AKA default less<>).
 */
NO_OP(sort, void, NO_CONST_TYPE)

#undef NO_OP

// Algorithms that iterate over a range applying a unary operator to
// each element.
#define UNARY_OP(name, result_type, const_type)				\
  template<class _Container, typename _Unary>				\
  inline result_type							\
  name(const_type _Container &__container,  _Unary __unary)		\
  {									\
    return std::name(begin(__container), end(__container), __unary);	\
  }

/**
 * Copy all container entries.
 */
UNARY_OP(copy, UNARY_OUT, CONST_TYPE)
/**
 * Iterate over all elements of a container, applying a unaery
 * operator to each.
 */
UNARY_OP(for_each, UNARY_OUT, CONST_TYPE)
/**
 * Find the first occurrence of a value.
 */
UNARY_OP(find, CONST_ITER, CONST_TYPE)
UNARY_OP(find, ITER, NO_CONST_TYPE)
UNARY_OP(find_if, CONST_ITER, CONST_TYPE)
UNARY_OP(find_if, ITER, NO_CONST_TYPE)
/**
 * Remove all items that compare equal to an argument value
 */
UNARY_OP(remove, ITER, NO_CONST_TYPE)
/**
 * Remove all items that satisfy a predicate
 */
UNARY_OP(remove_if, ITER, NO_CONST_TYPE)

#undef UNARY_OP

// Algorithms that iterate over a range applying an operator to each
// element and storing the result of that application to a container.
#define UNARY_OP_OUT(name, result_type, const_type)			\
  template<class _Container, typename _OutputIterator, typename _Unary>	\
  inline result_type							\
  name(const_type _Container &__container, _OutputIterator __result,	\
       _Unary __unary)							\
  {									\
    return std::name(begin(__container), end(__container), __result,	\
		     __unary);						\
  }

/**
 * Transform all container entries (AKA "map")
 */
UNARY_OP_OUT(transform, OUT_ITER, CONST_TYPE)
/**
 * Copy all items that satisfy a predicate
 */
UNARY_OP_OUT(copy_if, OUT_ITER, CONST_TYPE)

#undef UNARY_OP_OUT

#define BINARY_OP(name, result_type, const_type)			\
  template<class _Container, typename _Binary>				\
  inline result_type							\
  name(const_type _Container &__container, _Binary __binary)		\
  {									\
    return std::name(begin(__container), end(__container), __binary);	\
  }

/**
 * Sort an array using a binary comparison operator.
 */
BINARY_OP(sort, void, NO_CONST_TYPE)

#undef BINARY_OP

#define SEARCH_OP(name)							\
  template<class _Container, typename _SearchType, typename _Binary>	\
  inline typename _Container::iterator					\
  name(const _Container &__container, const _SearchType &__val,		\
       _Binary __binary)						\
  {									\
    return std::name(begin(__container), end(__container), __val,	\
		     __binary);						\
  }

/**
 * Find the first position in which an argument value can be inserted
 * without changing the ordering.
 */
SEARCH_OP(lower_bound);
SEARCH_OP(upper_bound);

#undef SEARCH_OP

#define PAIRWISE_BINARY_OP_OUT(name, result_type)			\
  template<typename _Container1, typename _Container2,			\
	   typename _OutputIterator, typename _Binary>			\
  inline result_type							\
  name(const _Container1 &__container1, const _Container2 &__container2, \
       _OutputIterator __result, _Binary __binary)			\
  {									\
    return std::name(begin(__container1), end(__container1),		\
		     begin(__container2), __result, __binary);		\
  }

/**
 * Transform the mixture of two containers.
 */
PAIRWISE_BINARY_OP_OUT(transform, OUT_ITER)

#undef PAIRWISE_BINARY_OP_OUT

#undef CONST_ITER
#undef OUT_ITER
#undef UNARY_OUT
#undef CONST_TYPE
#undef NO_CONST_TYPE

} // namespace jrl

#endif // STL_USABILITY_GUARD
